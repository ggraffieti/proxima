% !TeX spellcheck = it_IT
\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage{algorithmic}
\usepackage[utf8]{inputenc}
\usepackage{titling}
\usepackage{fancyhdr}
\usepackage{fontenc}
\usepackage{amsmath,mathtools,algorithm}
\usepackage{amssymb}
\usepackage{longtable}
\usepackage{setspace}
\usepackage{listings}
\usepackage{color}
\usepackage{eurosym}
\usepackage{array}
\usepackage[referable]{threeparttablex}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\usepackage[italian,hidelinks]{hyperref}

\usepackage[italian]{babel}
\usepackage[italian]{cleveref}

\lstdefinestyle{json}
{
	basicstyle = \footnotesize\ttfamily,
	frame = single,
	tabsize = 4
}

\lstdefinelanguage{myScala}{
	morekeywords={abstract,case,catch,class,def,%
		do,else,extends,false,final,finally,%
		for,if,implicit,import,match,mixin,%
		new,null,object,override,package,%
		private,protected,requires,return,sealed,%
		super,this,throw,trait,true,try,%
		type,val,var,while,with,yield},
	basicstyle=\ttfamily\small,
	sensitive=true,
	keywordstyle=\color{blue},
	morecomment=[l]{//},
	morecomment=[n]{/*}{*/},
	morestring=[b]",
	morestring=[b]',
	morestring=[b]"""
}


% MARGINI LARGHI
%\textwidth 6.3 in % Width of text line.
%    \textheight 9.2 in
%    \oddsidemargin 0 in      %   Left margin on odd-numbered pages.
%    \evensidemargin 0 in      %   Left margin on even-numbered pages.
%    \topmargin 0.2 in
%    \headheight 0 in       %   Width of marginal notes.
%    \headsep 0 in
%    \topskip 0 in

\pretitle{%
	\begin{center}
		\LARGE
	}
\posttitle{\end{center}}


\title{\Huge \textbf{Proxima} \\
	\vspace{10pt}
	\vspace{20pt}
}
\author{
	Gabriele Graffieti \\ \small \url{gabriele.graffieti@studio.unibo.it}
	\vspace{15pt}
	\\
	Alfredo Maffi \\ \small \url{alfredo.maffi@studio.unibo.it}
	\vspace{15pt}
	\\
	Manuel Peruzzi \\ \small \url{manuel.peruzzi@studio.unibo.it}
}

\date{}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\ifthenelse{\isodd{\value{page}}}{\thepage}{\leftmark}}
\fancyhead[R]{\ifthenelse{\isodd{\value{page}}}{\leftmark}{\thepage}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}} 

\begin{document}

\maketitle
\pagenumbering{arabic}


\tableofcontents

\chapter{Introduzione}

\chapter{Idea}
\section{Visione} \label{vision}
Negli ultimi anni si è assistito ad una sempre maggiore distribuzione di dispositivi di calcolo, inseriti anche nei più comuni oggetti di uso quotidiano. Ciò ha portato ad una distribuzione della computazione, che non è soltanto ad appannaggio dei dispositivi computazionali classici, ma ripartita in quasi ogni oggetto reale. 

Una delle sfide nel futuro della \emph{computer science} sarà quella di gestire l'interazione tra tutti questi oggetti, che dovranno interagire sia tra loro, che con gli esseri umani. Dato il numero sempre crescente di dispositivi, e la tipica bassa potenza computazionale di cui sono dotati, non è pensabile che l'interazione sia esplicita e avvenga nel mondo fisico. La nostra vision è quella di creare uno strato virtuale sopra alla realtà fisica, dove ogni dispositivo viene mappato in un'entità virtuale. Dato che l'interazione tra due oggetti acquista senso solamente se essi sono vicini tra loro nel mondo reale, i dispositivi fisici hanno il solo scopo di cercare altri dispositivi vicini nello spazio, per poi interagire con loro nello strato virtuale, rappresentato dal nostro sistema. 

Ogni componente del sistema, sia esso un dispositivo computazionale o una persona, avrà associato ad esso un identificativo, che agirà come \emph{entry point} per il sistema virtuale. I componenti, quindi, potranno ricercare altri componenti vicini nel mondo reale, ed attraverso l'identificativo poter interagire con loro nel mondo virtuale. In particolare l'interazione sarà automatica, e non richiederà alcuna azione esplicita. Sarà compito della controparte virtuale degli oggetti decidere se e come interagire, quali informazioni scambiare e con chi scambiarle.

Attraverso il deployment del sistema proposto saranno aperti vari nuovi scenari, tra cui
\begin{itemize}
	\item  Stravolgimento dell'interazione uomo-macchina, che non sarà più guidata da espliciti comandi, ma totalmente trasparente all'utente. Ad esempio, una casa intelligente può rilevare la presenza del proprietario nelle vicinanze, ed interagendo con il suo avatar virtuale può ricevere i dati di come il proprietario vuole interagire con essa (accensione luci in alcune stanze, accensione riscaldamento, apertura porte o finestre\dots) senza che il proprietario debba fisicamente fare alcuna azione
	\item Totale personalizzazione dell'interazione tra persona e dispositivo computazionale, che potrà essere imparata dal sistema in automatico tramite metodi di \emph{learning}.
	\item Metodi di pagamento automatico, senza l'obbligo del possesso di carte o moneta. Il dispositivo di pagamento rileverà in automatico le merci ed il compratore, e comunicando con i rispettivi avatar virtuali procederà al pagamento della merce. L'avatar del compratore potrà richiedere la conferma della persona reale prima di procedere. Sui mezzi pubblici non sarà più necessario l'acquisto del biglietto, ma semplicemente il mezzo, interagendo con gli avatar dei passeggeri, addebiterà il prezzo del bigliett all'ingresso nel mezzo.
	\item Scambio di dati tra persone fisiche, ad esempio dati medici o giudiziari. L'avatar di un medico contatterà l'avatar del paziente, che fornirà ad esso i dati medici, mostrati poi al medico nel mondo reale. In maniera simile un agente di polizia potrà ricevere i dati giudiziari di persone sospette, ad esempio per controlli negli aeroporti. 
	\item Scambio di dati tra dispositivi computazionali, ad esempio nel caso di un ricovero in terapia intensiva, l'avatar virtuale del ricovero (ad esempio legato fisicamente al letto) potrà aggregare tutti i dati rilevati dai sensori vicini (ossigenazione del sangue, elettrocardiogramma, temperatura\dots) per condividerli con i medici o eseguire \emph{learning} sugli stessi, in modo da rilevare ed anticipare peggioramenti o miglioramenti del paziente.
\end{itemize}

\section{Goal} \label{goal}
L'obiettivo di questo elaborato è la progettazione e l'implementazione del primo scheletro del sistema, in modo da creare l'infrastruttura generale, che sarà poi estesa in modo da implementare le funzionalità descritte in \autoref{vision}. Oltre a produrre la base del sistema ci si concentrerà su un caso concreto, in modo da mostrare fin da subito l'utilità dell'idea proposta. 

Una delle maggiori problematiche nell'ambito del primo soccorso, è quella di riconoscere velocemente il paziente, e accedere quindi rapidamente ai suoi dati medici, quali allergie o farmaci assunti abitualmente. La conoscenza di tali dati da parte del medico di primo soccorso è vitale per operare in modo sicuro, ed evitare di peggiorare la situazione clinica del paziente. Spesso non è possibile avere un veloce accesso a tali dati, dato che il paziente può essere privo di conoscenza, in stato di shock o incapace di comunicare. Inoltre la consultazione delle informazioni avviene solamente una volta arrivati in ospedale: esse non sono quindi disponibili durante il primo soccorso ed il trasporto.

L'obiettivo di questo elaborato è quello di risolvere il problema attraverso il sistema \emph{Proxima}: il medico rileverà la presenza di un paziente nelle vicinanze, interagirà virtualmente con lui e riceverà i dati medici nel mondo fisico, senza alcun bisogno di interazione diretta, spesso impossibile. Verrà, perciò, prima implementata la parte generale del sistema, e poi mostrata la sua potenzialità in un caso reale, come quello descritto.  

\chapter{Analisi dei requisiti} \label{requirements}
\section{Idea}
Il sistema \emph{Proxima} nasce dalla necessità di fornire un supporto, in caso di emergenza, ai soccorritori accorsi sul posto. Ogni persona dovrà essere munita di un dispositivo di identificazione, che potrà essere letto dal soccorritore, tramite l'utilizzo di un apposito lettore. Tale lettore dovrà essere provvisto di schermo, sul quale saranno visualizzati i dati medici del paziente, in modo da consentire interventi mirati e con maggiore sicurezza. 

\section{Requisiti funzionali}
\begin{description}
	\item \textbf{Identificatore}: ogni utilizzatore del servizio dovrà essere costantemente in possesso di tale dispositivo, che dovrà quindi essere compatto, non ingombrante e possibilmente indossabile. Inoltre, la sua durata media di funzionamento non dovrà essere inferiore a 3 anni. Esso sarà caratterizzato dalle seguenti funzionalità: 
	\begin{itemize}
		\item Identificare l'utente in maniera univoca.
		\item La trasmissione dell'identificativo dovrà avvenire in modalità \emph{wireless}, con un raggio massimo da 1 a 3 metri.
		\item Lo scambio dell'identificativo dovrà avvenire in maniera trasparente all'utente, senza consensi espliciti ad ogni trasmissione.
	\end{itemize}

	\item \textbf{Lettore}: dispositivo che dovrà essere in possesso del soccorritore, in modo che possa identificare e mostrare i dati degli utenti. Per fare ciò dovrà essere in grado di comunicare sia con gli identificatori, sia con la banca dati. Il dispositivo dovrà avere le seguenti funzionalità:
	\begin{itemize}
		\item Permettere la ricerca degli identificatori nelle vicinanze (raggio massimo da 1 a 3 metri). La ricerca dovrà essere esplicitamente avviata dal soccorritore, e dovrà essere possibile interromperla.
		\item Nel caso durante la fase di ricerca siano stati trovati degli identificatori, il lettore dovrà essere in grado di recuperare l'identificativo dei relativi possessori.
		\item Contattare la banca dati remota in modo da acquisire i dati medici relativi al paziente identificato dall'identificativo recuperato in precedenza.
		\item Attraverso il lettore dovrà essere possibile identificare in maniera univoca il soccorritore, in modo che il sistema possa decidere se il soccorritore sia autorizzato alla lettura delle informazioni mediche dell'utente.
		\item Mostrare le informazioni mediche del paziente al soccorritore.
	\end{itemize}
\end{description}

I dati medici degli utenti sono forniti sotto forma di banca dati elettronica, accessibile attraverso la rete internet. All'interno della banca dati fornita sono conservate anche le informazioni sui turni dei soccorritori. 

Il sistema dovrà definire una politica di accesso ai dati contenuti nella banca dati sulla base dell'identità dei soccorritori e dei turni di lavoro. 

\section{Glossario} \label{glossary}
In questa sezione verranno esplorati ed esplicati i concetti chiave usati dal committente durante la fase di raccolta dei requisiti. 
\begin{itemize}
	\item \textbf{Soccorritore}: medico o infermiere che presta soccorso ai pazienti sia in ospedale, che anche all'esterno in caso di emergenze. Nella definizione di soccorritore data dal committente, non è incluso il personale che non è adibito ad un intervento invasivo diretto sul paziente (personale volontario e non senza abilitazioni mediche/infermieristiche). Ad esempio, a bordo di un'ambulanza atta a svolgere una funzione di trasporto e di primo soccorso, è consuetudine la presenza di personale (volontario e non), la cui mansione è limitata ad una prima stabilizzazione del paziente, oltre al trasporto dello stesso presso un centro ospedaliero. Tale personale non è considerato in questa categoria.
	\item \textbf{Paziente}: Persona che necessita di cure mediche in una situazione di emergenza. Sono inclusi in questa categoria sia i soggetti che si recano in ospedale in autonomia, sia i soggetti che giungono in ospedale scortati da appositi mezzi di trasporto (come ambulanze).
	\item \textbf{Situazione di emergenza}: Circostanza o condizione di immediato pericolo per la salute del paziente, che necessita di un perentorio intervento di uno o più soccorritori (ad esempio traumi dovuti ad incidenti automobilistici, condizioni acute quali infarto, ictus, \dots).
	\item \textbf{Identificativo}: codice che permette di risalire all'identità di un certo utente all'interno del sistema. Esso deve contenere la minima quantità di informazione che consente di identificare un paziente che è in possesso di un identificatore
	\item \textbf{Lettore}: dispositivo Android (smartphone, tablet), in grado di recuperare l'identificativo del paziente dall'identificatore e dotato di una costante connessione di rete, in modo da poter comunicare con la base di dati remota fornita dal committente. Su richiesta, le funzionalità del lettore devono essere condensate all'interno di un'applicazione nativa Android.
	\item \textbf{Dati medici}: dati relativi al paziente che risultano particolarmente utili al soccorritore nella fase di primo soccorso. Tali informazioni sono contenute all'interno della banca dati fornita dal committente. Nello specifico, esse sono relative a:
	\begin{itemize}
		\item Breve anagrafica del paziente (nome, cognome, codice fiscale, data di nascita).
		\item Gruppo sanguigno.
		\item Consenso o meno alla donazione di organi.
		\item Malattie (ad esempio sclerosi multipla, fibrosi cistica, \dots).
		\item Allergie ai medicinali, ai cibi (come arachidi, latte, \dots), alle punture di insetti, ai materiali e ad altre svariate sostanze.
		\item Medicinali abitualmente assunti dal paziente.
	\end{itemize}
	Un sottoinsieme dei dati sopra elencati è soggetto a variazioni nel tempo (ad esempio i medicinali assunti), la banca dati conterrà sempre la versione attuale delle informazioni, e verrà quindi aggiornata periodicamente.  
	\item \textbf{Turno del soccorritore}: fasce orarie nelle quali il soccorritore presta il suo servizio in ospedale o nei mezzi adibiti al primo soccorso e al trasporto dei pazienti. Il turno di un soccorritore è soggetto a variazioni nel tempo, comportando un conseguente aggiornamento della banca dati.
\end{itemize}

\section{Scenari} \label{scenarios}
È possibile individuare due scenari di interesse, a seconda del luogo in cui il servizio viene utilizzato.
\subsection{Scenario 1} \label{scenario1}
In una situazione di emergenza, il soccorritore arriva sul posto, apre l'applicazione sul proprio lettore e si autentica nel sistema. 

\subsubsection*{Scenario 1.1}
Inizia la ricerca degli identificatori nelle vicinanze. Se uno o più identificatori sono rilevati, viene recuperato l'identificativo di quello che risulta essere più vicino. I dati medici del paziente sono poi mostrati sullo schermo del dispositivo, in modo da fornire un supporto per il soccorritore.

\subsubsection*{Scenario 1.2}
Inizia la ricerca degli identificatori nelle vicinanze. Se uno o più identificatori sono rilevati, viene recuperato l'identificativo di quello che risulta essere più vicino. Nel caso in cui il soccorritore non sia autorizzato alla lettura dei dati (in quanto non qualificato o non in un turno lavorativo), l'accesso ai dati è negato e viene mostrato un messaggio che avvisa il soccorritore di intervenire ``manualmente'', senza contare sul servizio.
\subsubsection*{Scenario 1.3} 
Non è possibile contattare la banca dati, viene mostrato un messaggio che avvisa il soccorritore di intervenire ``manualmente'', senza poter contare sul servizio.
\subsubsection*{Scenario 1.4}
Il paziente non è in possesso di un identificatore, il medico deve intervenire  ``manualmente'', senza poter contare sul servizio.

\subsection{Scenario 2}
Il paziente giunge in ospedale per richiedere assistenza medica, in una situazione di emergenza. Il soccorritore (medico o infermiere di turno in ospedale) apre l'applicazione sul proprio lettore e si autentica nel sistema. 

I possibili sotto-scenari che si possono manifestare corrispondono a quelli descritti in \autoref{scenario1}. In questo caso, però, il luogo nel quale avviene il soccorso è un reparto di una struttura ospedaliera attrezzata, nella quale è garantita la presenza dei soli soccorritori autorizzati e una costante connettività. 

Se il paziente è in possesso di un identificatore, esso viene rilevato nella fase di ricerca del lettore e i dati medici del paziente sono mostrati sullo schermo del lettore, in modo da fornire un supporto per il soccorritore. Altrimenti il medico deve intervenire "manualmente" senza poter contare sul servizio.

\section{Requisiti non funzionali}
Il sistema dovrà essere progettato e sviluppato in modo da fornire un servizio a livello nazionale (Italia). 
Di seguito sono elencati i requisiti non funzionali del sistema:
\begin{itemize}
	\item \textbf{Costi}: il costo dell'identificatore non dovrà superare i 5 euro per unità. I dispositivi \emph{Android} utilizzati come lettori dovranno essere acquistati, ed il loro prezzo non dovrà superare i 200 euro per unità.
	\item \textbf{Sicurezza e privacy}: tutte le comunicazioni tra i componenti del sistema dovranno essere sicure, e non sarà possibile l'intercettazione dei dati da parte di soggetti non autorizzati. I dati medici dei pazienti sono dati sensibili, ed il loro accesso dovrà essere garantito solamente ai soccorritori, e solamente in reali situazioni di emergenza. I dati dovranno essere conservati e trasmessi in modo sicuro, in modo da garantire la loro integrità. Per questioni legali ogni accesso ai dati dovrà essere opportunamente memorizzato, in modo che sia sempre possibile risalire a quale soccorritore ha letto i dati del dato paziente. Non dovrà essere possibile che un paziente sia scambiato con un altro, o che volontariamente assuma l'identità di un'altra persona.
	\item \textbf{Availability}: il servizio offerto dovrà essere sempre consultabile, e dovrà fornire i dati medici corretti ad ogni interazione con i soccorritori autorizzati. Il sistema dovrà essere raggiungibile da qualunque luogo, a patto che sia possibile stabilire una connessione internet. Il ritardo di risposta del sistema (assumendo tempo zero per la trasmissione dei dati) non dovrà mai superare i 2 secondi.
	\item \textbf{Scalability}: il sistema avrà per lo più un carico di lavoro costante, ma dovrà gestire anche picchi di richieste, dovuti ad esempio a catastrofi naturali, attacchi terroristici ecc\dots Il tempo di risposta massimo dovrà essere sempre mantenuto al di sotto del valore espresso precedentemente, indipendentemente dal numero di richieste che il sistema dovrà gestire. 
	\item \textbf{Fault tolerance}: nel caso non sia possibile stabilire una connessione con il sistema dovrà essere mostrato un avviso al soccorritore di modo che intervenga sul paziente senza fare affidamento sul sistema. In questo modo non viene perso tempo prezioso nella ricerca e nell'identificazione del paziente. I dati medici dovranno essere in ogni caso recuperabili, anche a seguito di fallimenti del sistema. Essi, infatti, non dovranno mai venire persi. 
	\item \textbf{User experience}: i dati medici dovranno essere mostrati al soccorritore in modo da facilitare la loro lettura e consultazione. Essi, infatti, dovranno essere letti in fasi particolarmente concitate, per cui la loro presentazione non dovrà far perdere tempo al soccorritore, oltre a quello necessario alla loro lettura. 
\end{itemize}

\section{Domain model} \label{domain-model}
\subsection{Banca dati}
Il committente ha reso disponibile una base dati, la quale contiene le informazioni mediche dei pazienti. I dati sono memorizzati all'interno della banca dati attraverso un database \emph{MongoDB}\footnote{\url{https://www.mongodb.com}}, e strutturati in documenti \emph{JSON}\footnote{\url{https://www.json.org}}. I dati sono contenuti in un'unica collezione chiamata \emph{medicalData}. La struttura dei dati è riportata di seguito:
\begin{lstlisting}[style=json, caption={Esempio di una entry all'interno del database dato.}, captionpos=b]
{
	"_id": ObjectId("507f1f77bcf86cd799439011"),
	"name": "John",
	"surname": "Doe",
	"CF": "DOEJHN70P16F205Y",
	"birthDate": "1970-09-16T00:00:00.000Z",
	"bloodGroup": "A+",
	"organDonor": "YES",
	"medicalConditions": [
		"Heart Disease",
		"Diabetes type 2",
		"Pacemaker"
	],
	"drugAllergies": [
		"Penicillan",
		"Morphine"
	],
	"otherAllergies": [
		"Peanuts",
		"Bee sting",
		"Latex",
		"Wheat"
	],
	"medications": [
		"Prozac",
		"Refludan",
		"Hydrochiorothiazide",
		"Cialis",
		"Plavix"
	]
}
\end{lstlisting}

Similmente la base dati contenente i turni dei soccorritori è fornita, e anch'essa consta di una collezione \emph{MongoDB}, chiamata \emph{RescuersWorkSchedule}. Il formato dei dati è riportato di seguito:

\begin{lstlisting}[style=json, caption={Esempio di un turno lavorativo all'interno della banca dati. Gli orari di inizio e fine turno sono espressi in numero di secondi dopo la mezzanotte del giorno stesso. In uno stesso giorno un soccorritore può avere assegnati più turni.}, captionpos=b]
{
	"rescuerID": "df54f5gdfh4",
	"monday": [
		{
			"begin": 0,
			"end": 21600
		},
		{
			"begin": 79200,
			"end": 86499
		}
	],
	"tuesday": [
		{
			"begin": 0,
			"end": 25200
		}
	],
	
	...
	
}
\end{lstlisting}

La banca dati viene messa a disposizione tramite una connessione diretta al database server di MongoDB, residente all'indirizzo di rete fornito dal committente. La comunicazione dovrà avvenire attraverso il protocollo \emph{MongoDB Wire Protocol}\footnote{\url{https://docs.mongodb.com/manual/reference/mongodb-wire-protocol}}, che si basa su TCP/IP. L'accesso dato è direttamente al database, e non passerà da API, in questo modo sarà possibile lavorare sulla banca dati come se essa fosse in locale. 
\subsection{Modello}
La fase di raccolta dei requisiti ha permesso una comprensione delle richieste del committente, che sono state definite ed esplicate in forma testuale nelle sezioni precedenti. Una rappresentazione più efficacie dei requisiti può essere raggiunta attraverso la costruzione di un modello del dominio, in grado di catturare gli aspetti chiave del sistema. 

In questa fase, la costruzione di un modello del dominio ha un duplice scopo, in quanto permette:
\begin{itemize}
	\item Una definizione formale dei requisiti, che costituisce un input per la successive fasi di analisi e progettazione.
	\item Un confronto diretto con il committente, in modo da confermare o smentire la comprensione dei requisiti raccolti. 
\end{itemize}

La criticità principale di questo approccio consiste nella realizzazione di un modello comprensibile sia all'interno della \emph{software house}, sia al committente. La realizzazione di un modello eseguibile permette di evitare tale problematica, attraverso la costruzione di uno o più prototipi funzionanti in tempi brevi. Il prototipo consente di definire il comportamento generale del sistema e sarà sottoposto all'attenzione del committente. 

Il modello del dominio è stato definito tramite l'utilizzo del meta-modello \emph{QActor}, sviluppato dal professore Antonio Natali. \emph{QActor} è un linguaggio \emph{custom} che consente di esprimere in maniera concisa la struttura, l'interazione ed il comportamento di un sistema software eterogeneo e distribuito.

Sulla base dei requisiti, si procede in maniera incrementale alla realizzazione di due modelli:
\begin{itemize}
	\item \textbf{Base model}: si individuano nel sistema tre componenti principali, nello specifico patient, doctor e control (componente che gestisce l'accesso alla banca dati), modellati come entità attive (attori). I componenti sono considerati come delle \emph{black-boxes}, ponendo il focus sulla loro interazione. Dal modello emerge il comportamento del sistema, il cui scopo è quello di permettere al soccorritore di reperire i dati medici (in questo caso simulati) del paziente a lui più vicino.
	\item \textbf{Authorization model}: estensione del modello base attraverso l'introduzione di un vincolo che impedisce l'accesso ai dati ai soccorritori non autorizzati.
\end{itemize}
I modelli sopra illustrati sono eseguibili e costituiscono dei primi prototipi funzionanti del sistema. Questa caratteristica permette un confronto diretto con il committente, in modo da valutare la comprensione dei requisiti.

\section{Test plan}
I requisiti, raccolti ed analizzati in \autoref{requirements}, devono guidare l'intero processo di progettazione e sviluppo del progetto. È necessario definire le modalità attraverso le quali dovrà avvenire la verifica dei requisiti, in modo da poter valutare in ogni fase del progetto la conformità del prodotto rispetto ai requisiti.

Si individuano due funzionalità principali del sistema che dovranno essere soggette al processo di testing.
\begin{description}
	\item \textbf{Correttezza dei dati}: un soccorritore, dopo aver avviato la ricerca di identificatori nelle vicinanze, deve ricevere esclusivamente i dati medici relativi al paziente più vicino. I dati ricevuti devono essere quelli contenuti all'interno della banca dati per il paziente specifico (come stabilito in \autoref{glossary}).
	\item \textbf{Gestione dell'accesso ai dati}: un soccorritore non autorizzato non deve poter ricevere alcun dato medico. Le informazioni che definiscono l'autorizzazione o meno di un certo soccorritore sono quelle contenute all'interno della banca dati (come stabilito in \autoref{glossary}). 
\end{description}

\chapter{Analisi del problema}
\section{Analisi del sistema generale}
Come anticipato nella \autoref{goal}, lo scopo del progetto non è soltanto quello di soddisfare i requisiti esposti nel \autoref{requirements}, ma di costruire la base di tutto il sistema, sopra la quale saranno implementati i servizi, tra i quali quello di gestione delle emergenze mediche esposto in precedenza. Il sistema \emph{Proxima} dovrà quindi fornire una base, sopra la quale potranno essere costruiti servizi e componenti. Esso agirà quindi da \emph{middleware}, e dovrà fornire ai servizi ed agli utenti le seguenti funzionalità:
\begin{itemize}
	\item Servizio di identificazione. Esso sarà la base del sistema, attraverso cui tutte le funzionalità potranno essere implementate. L'identificazione dovrà essere univoca, e offerta come servizio a chiunque voglia interagire con il sistema. Sarà ovviamente compito del sistema stesso gestire l'accesso ai dati, che dovrà essere garantito solo a chi autorizzato. I vari servizi non dovranno essere accessibili in modo diretto, ma solamente attraverso il sistema \emph{Proxima}.
	\item Dovrà essere possibile, in modo semplice, estendere il sistema con un nuovo servizio, senza che l'architettura generale del sistema debba essere ripensata. Ogni servizio sarà responsabile per i dati degli utenti inerenti ad esso, in modo che non esista una unica base dati centralizzata. I servizi dovranno essere implementati nel modo più semplice possibile, sfruttando ciò che il sistema generale mette a disposizione. La politica di accesso ai dati sarà gestita sia dal sistema generale sia dai servizi stessi. In pratica ogni servizio dovrà essere responsabile delle informazioni sugli utenti che contiene, ed in parte anche delle politiche di accesso ad esse.
	\item Ogni utente potrà, a sua discrezione, decidere quali dati rendere pubblici per la lettura. Notare che solamente chi autorizzato può, in ogni caso, leggere i dati. L'utente può decidere in qualsiasi momento la politica di gestione dei dati, ad esempio decidendo di non condividere mai i dati inerenti ai suoi acquisti in un dato supermercato. Alcune categorie di dati, come quelli medici o giudiziari, dovranno essere sempre consultabili, ovviamente da personale autorizzato (in questo caso medici e pubblici ufficiali).
	\item Il sistema generale dovrà implementare una comunicazione sicura con i lettori, in modo che nessun dato trasmesso possa essere intercettato o modificato. La sicurezza delle comunicazioni dovrà essere gestita in modo centrale, e non lasciata come compito ai singoli servizi. Inoltre anche la comunicazione tra servizi e sistema generale dovrà essere sicura ed al riparo da qualsiasi attacco. I protocolli di comunicazione tra tutti i componenti del sistema dovranno essere ben definiti, in modo che sia facile una sua estensione. 
	\item Il sistema dovrà essere sempre consultabile, e i tempi di risposta dovranno essere brevi, indipendentemente dal numero di richieste in corso nello stesso momento. Ciò significa che il sistema generale dovrà possedere i requisiti di \emph{availability} e \emph{scalability}.
	\item Il sistema dovrà essere resistente ad i guasti, in particolare quelli relativi a manomissioni dell'hardware, attacchi informatici al software o attacchi \emph{Denial of Service}. Esso dovrà garantire un livello di servizio accettabile anche in presenza di tali attacchi, e dovrà essere sempre possibile recuperare la piena funzionalità dello stesso, sia in caso di attacchi sia di catastrofi naturali. 
\end{itemize}
\section{Problematiche}\label{issues}
In questa sezione verranno esaminate le varie problematiche che scaturiscono da un'analisi del sistema.
\begin{description}
	\item[Identificatore]: come emerge dai requisiti, il dispositivo dovrà essere a basso consumo, in quanto la sua durata media non potrà essere inferiore a 3 anni. Questo vincolo, in combinazione con il budget limitato (5 euro per unità) e le dimensioni ridotte, crea la necessità di una ricerca sul mercato, in modo da verificare l'esistenza di dispositivi compatibili.
	
	Il dispositivo dovrà essere in grado di comunicare in modalità wireless con il lettore. Siccome il lettore, da requisiti, sarà un device Android (con un costo inferiore ai 200 euro per unità), le tecnologie di comunicazione utilizzabili si riducono a quelle supportate da tale device. Risulta quindi necessaria un'analisi di queste tecnologie, in modo da poter individuare il dispositivo più appropriato compatibile con almeno una di esse. 
	
	\item[Trasmissione dell'identificativo]: i requisiti stabiliscono la presenza di una fase di ricerca, attraverso la quale il lettore è in grado di scoprire gli identificatori all'interno di un raggio limitato. Fra le tecnologie supportate da Android è necessario individuare solamente quelle che permettono di osservare questo vincolo. Inoltre, la tecnologia in oggetto deve poter permettere di stimare in maniera precisa la distanza del lettore dagli identificatori, in modo da stabilire con quale di questi effettuare l'interazione.
	
	Durante l'utilizzo concreto del sistema, vi è la possibilità che l'identificatore stimato come più vicino al lettore, possa non essere quello appartenente al paziente che necessita di soccorso. Immaginiamo, ad esempio, una situazione nella quale il paziente si trovi circondato da altre persone, anch'esse in possesso di un proprio identificatore. In questo caso, l'identificatore rilevato dal lettore del soccorritore, giunto sul posto, potrebbe non essere quello desiderato. Inoltre, è lecito pensare che il soccorritore stesso sia munito di un proprio identificatore, che quindi potrebbe essere confuso con quello del paziente. Una situazione come quella appena descritta è in contrasto con i requisiti, in quanto il soccorritore non è tenuto a consultare i dati medici relativi a persone che non sono coinvolte in una situazione di emergenza. 
	
	\item[Banca dati]: la banca dati è un archivio elettronico già esistente gestito da entità terze, che hanno il compito di mantenerla aggiornata. Non è quindi possibile assumere che un certo dato, precedentemente reperito dalla banca dati, sia consistente rispetto alla versione attuale. 
	
	La banca dati non fornisce alcun meccanismo per regolare l'accesso ai dati. Sarà quindi necessaria l'introduzione di un componente aggiuntivo, avente lo scopo di permettere l'accesso ai dati solamente ai soccorritori autorizzati.
	
	\item[Autenticazione del soccorritore]: l'accesso ai dati medici è consentito solamente ai soccorritori autorizzati. Una problematica che si viene a creare consiste nel determinare l'identità di un soccorritore che richiede un accesso alla banca dati. Si rende necessaria, quindi, la presenza di una fase di autenticazione di un soccorritore nel sistema, tramite la quale egli può confermare la propria identità.
	
	\item[Sicurezza]: il sistema è esposto a vari problemi riguardanti la sicurezza informatica, alcuni dichiarati esplicitamente dal committente e altri derivanti dall'analisi. 
	\begin{itemize}
		\item \emph{Tracciabilità}: dato che nei requisiti non è stato posto alcun vincolo riguardante la lettura dell'identificativo dei pazienti, ogni soggetto, tramite l'utilizzo di un lettore, è in grado di recuperare e memorizzare l'identificativo di ogni persona in possesso di un identificatore. Se l'identificativo contiene dei dati che possano permettere un'identificazione diretta del soggetto (ad esempio nome e cognome, codice fiscale, \dots), significa che un malintenzionato può risalire all'identità di tutte le persone nelle sue immediate vicinanze. Nel caso il malintenzionato sia anche un soccorritore autorizzato, egli potrebbe garantirsi un accesso continuo ai dati medici anche al di fuori delle situazioni di emergenza.
		\item \emph{Masquerade}: un malintenzionato potrebbe acquisire l'identificativo di un soggetto e utilizzarlo come proprio. In questo modo egli potrebbe, a tutti gli effetti, spacciarsi per un'altra persona. Nello specifico dominio medico, tale comportamento non permette di conseguire dei vantaggi evidenti, ma in un ambito più ampio e generale il malintenzionato potrebbe, così facendo, ottenere dei benefici non indifferenti. 
		\item \emph{Sniffing}: un malintenzionato potrebbe intercettare il flusso di informazioni scambiato tra il lettore di un soccorritore autorizzato e la banca dati. Così facendo, egli avrebbe un accesso diretto a tutti i dati medici di ogni paziente soccorso dal soccorritore.
		\item \emph{Replay attack}: un malintenzionato potrebbe intercettare la richiesta di dati medici di un paziente inviata dal lettore verso la banca dati. Tale richiesta potrebbe poi essere nuovamente inviata alla banca dati, ma questa volta da parte del malintenzionato, che così facendo potrebbe recuperare i dati medici del paziente.
		\item \emph{Identificativo compromesso}: nel caso l'identificatore di un soggetto venga perso/rubato/compromesso, egli non potrà usufruire del servizio, in quanto non sarebbe possibile una sua identificazione da parte di un soccorritore. Inoltre, chiunque venisse in possesso dell'identificatore in questione, potrebbe in ogni momento spacciarsi per il legittimo proprietario.
		\item \emph{Insider threats}: problema di distinguere accessi leciti e non alla banca dati. Ad esempio, un soccorritore autorizzato può potenzialmente accedere ai dati di ogni paziente (dato il relativo identificativo), ma tale accesso risulterebbe illecito nel caso venisse svolto al di fuori di una situazione di emergenza.
		\item \emph{Privacy}: i dati medici di un paziente acquisiti da un soccorritore autorizzato potrebbero, in un secondo momento, essere ri-consultati o divulgati dal soccorritore stesso, violando così la privacy del paziente.
	\end{itemize} 
\end{description}
Le problematiche fin qui illustrate si limitano allo specifico ambito medico. Come anticipato in \autoref{goal}, il caso medico è solamente un sottoinsieme del sistema generale, la cui idea è illustrata in \autoref{vision}. 

\section{Studio di fattibilità} \label{feasibility}

\subsection{Sicurezza}

Ogni problematica relativa alla sicurezza accennata in \autoref{issues} necessita di un'analisi dettagliata, atta a stabilire se e come la problematica stessa sia risolvibile nella pratica rispettando i requisiti.
\begin{itemize}
	\item \emph{Tracciabilità}: per fare in modo di evitare che un malintenzionato in possesso di un lettore possa ricostruire l'identità di un certo utente attraverso la sola lettura del suo identificativo, si potrebbe ricorrere all'uso di crittografia. Nel caso identificatore e banca dati condividessero una chiave segreta, allora il primo potrebbe criptare l'identificativo in modo che solo la banca dati possa effettivamente leggerlo. Inoltre, si potrebbe utilizzare crittografia a chiave pubblica, in modo da ottenere lo stesso risultato senza la necessità che la banca dati sia a conoscenza della chiave segreta di ogni identificatore. Questo approccio, tuttavia, presenta due problematiche. La prima consiste in una limitazione della scelta dell'identificatore ai soli in grado di eseguire operazioni di crittografia; la seconda consiste in un'aggiunta di overhead nelle interazioni tra i componenti del sistema e in un maggior consumo della batteria per le operazione crittografiche. In alternativa, si potrebbe decidere di strutturare gli identificativi come sequenze casuali di caratteri, in modo che non sia necessaria alcuna operazione di crittografia e che un eventuale malintenzionato non riesca a risalire all'identità di una persona con il solo identificativo. Questo approccio inoltre non vincolerebbe la scelta dell'identificatore, che potrebbe essere un semplice tag NFC.
	
	Nel caso si decidesse di adottare uno di questi due approcci, un eventuale malintenzionato sarebbe comunque in grado, ad esempio, di tracciare i movimenti di un certo utente. Infatti, nonostante il contenuto dell'identificativo sia indecifrabile, il malintenzionato potrebbe comunque associare, in maniera univoca, un certo identificativo al possessore, potendo così seguire i suoi movimenti quando si trova in sua prossimità. Questo problema potrebbe essere risolto facendo in modo che gli identificatori emettessero un identificativo diverso ogni volta, come descritto nel seguente punto. 
	\item \emph{Masquerade}: per evitare che un malintenzionato, venuto in possesso di un identificativo altrui, lo usi spacciandosi per il legittimo possessore si potrebbe ricorrere all'uso di identificativi \emph{one-shot}. L'idea è che identificatore e banca dati condividano un sequenza ordinata di identificativi e che siano concordi su di un identificativo di partenza. Ad ogni richiesta, l'identificatore fornirà un identificativo diverso, seguendo progressivamente l'ordine della sequenza. La banca dati seguirà lo stesso ordine e, a fronte di una richiesta da parte di un lettore, confronterà l'identificativo ottenuto con quello aspettato per capire se la richiesta sia valida o meno. Questo approccio risolve la problematica in questione, ma introduce un ulteriore problema, ovvero quello di mantenere sincronizzate le sequenze di lettore e banca dati. Nel caso venisse a crearsi una discrepanza tra le due, allora non sarebbe più possibile recuperare i dati relativi alla persona in possesso dell'identificatore.
	
	In alternativa a questo approccio, si potrebbe ricorrere ad una interazione di tipo \emph{challenge-response}. Alla ricezione di ogni richiesta, la banca dati non invierà dati medici in risposta, ma bensì un certo quantitativo di informazioni (\emph{challenge}), che il lettore dovrà inoltrare all'identificatore interrogato. Questo cripterà tali informazioni con una propria chiave privata. Il contenuto criptato verrà restituito alla banca dati, sempre attraverso il lettore. A questo punto, la banca dati potrà verificare l'autenticità dell'identificatore decriptando ciò che ha ottenuto con la chiave pubblica dello stesso. Questo approccio introdurrebbe, tuttavia, un overhead nelle interazioni tra i componenti del sistema e un maggior consumo della batteria dell'identificatore, per via delle operazioni crittografiche.
	
	In ambito medico la problematica di \emph{masquerade} non dovrebbe avere riscontri pratici, in quanto non si avrebbero vantaggi nel fornire, ad un soccorritore, dati medici altrui al posto dei propri. In altri ambiti, come ad esempio in quello commerciale, quanto appena detto non sussiste. In un'ottica più generale infatti, qualora un utente fosse abilitato ad effettuare transazioni economiche tramite il servizio, un attacco di tipo \emph{masquerade} diverrebbe molto più sensato ed appetibile. Nel caso non si volesse ricorrere agli approcci sopra citati, questo problema si potrebbe risolvere facendo sì che per determinate azioni effettuabili tramite il servizio vi debba obbligatoriamente essere un consenso esplicito da parte dell'utente. Tale consenso potrebbe essere espresso, ad esempio, tramite un app sul proprio smartphone. 
	
	\item \emph{Sniffing} \& \emph{Replay Attack}: nel caso la comunicazione via Internet tra lettore e banca dati avvenisse in chiaro, nulla impedirebbe ad un eventuale malintenzionato di intercettare il traffico di rete generato dagli stessi. In questo modo esso sarebbe in grado di leggere il contenuto informativo di tutte le risposte inviate dalla banca dati verso il lettore. Inoltre, il malintenzionato potrebbe intercettare una certa richiesta creata dal lettore e inoltrarla in seguito alla banca dati per ricevere tutte le informazioni mediche relative ad un determinato paziente. Nella pratica, per risolvere questi problemi è necessario ricorrere all'uso di crittografia per le comunicazioni. Nel nostro caso si potrebbe quindi utilizzare HTTPs al posto di HTTP, in modo che la totalità del traffico di rete scambiato tra lettore del soccorritore e banca dati sia indecifrabile da parte di malintenzionati. L'utilizzo di HTTPs, tuttavia, richiede che la banca dati sia in possesso di un certificato autentico.
	
	\item \emph{Identificativo compromesso}: non esistono soluzioni complete per fare fronte, in maniera automatizzata, a smarrimenti o furti di identificativi. Quel che si può fare è dare agli utenti del servizio la possibilità di denunciare tali avvenimenti, in modo che l'identificativo di interesse possa venire disabilitato. In tal caso, all'utente verrà consegnato un nuovo identificativo e la banca dati verrà aggiornata di conseguenza.
	
	\item \emph{Insider threats}: il problema degli accessi illeciti ai dati parte di soccorritori autorizzati risulta essere tra i più delicati. Anche in questo caso, purtroppo non esiste una soluzione totalmente automatizzata che permetta di eliminare
	completamente il problema. Tuttavia, per far fronte ad esso potrebbe venire memorizzato, nella banca dati, un file di \emph{log} contenente tutti gli accessi ai dati da parte di tutti i soccorritori, ognuno corredato da un \emph{timestamp}. Questo file potrebbe poi essere consultato per effettuare controlli sugli accessi stessi, verificando  che ognuno di questi abbia effettivamente avuto luogo in una situazione di emergenza.
	
	\item \emph{Privacy}: un determinato soccorritore, una volta entrato in possesso dei dati sensibili di un paziente in seguito ad una situazione di emergenza, potrebbe riutilizzarli e, ad esempio, divulgarli. Questo risulterebbe in una violazione della privacy del paziente. Purtroppo non vi è modo di impedire che ciò accada; il soccorritore potrebbe infatti, ad esempio, segnarsi i dati dopo averli visualizzati. Quel che si può fare è limitarsi a non memorizzare alcun dato sensibile all'interno del lettore e stabilire i provvedimenti da prendere nel caso si scopra vi sia stata una violazione della privacy da parte di un certo soccorritore.
\end{itemize}

\subsection{Banca Dati}

Come discusso in \autoref{issues}, i dati presenti all'interno della banca dati fornita sono gestiti da entità terze, che hanno la responsabilità di mantenerli aggiornati e quindi modificarli nel tempo. Questo rende problematica la memorizzazione dei dati stessi sul lettore del soccorritore, che potrebbe essere utile per questioni di performance. Infatti, qualora alcuni dati venissero memorizzati localmente, quelli all'interno della banca potrebbero venire aggiornati in seguito, creando così inconsistenza tra le due copie. Nella pratica, è possibile affrontare questa problematica in due modi:
\begin{enumerate}
	\item Si potrebbe fare in modo di notificare, tramite Internet, i lettori di tutti i soccorritori ogniqualvolta un certo dato nella banca dati viene modificato. Alla ricezione di una notifica, il lettore aggiornerà, se necessario, i dati salvati in precedenza, evitando così la creazione di inconsistenze. Tuttavia, questo approccio presenta vari difetti: occorrerebbe definire una politica da attuare nel caso i lettori non fossero contattabili al momento dell'invio delle notifiche; inoltre, molto probabilmente non tutti i lettori saranno interessati alla totalità delle notifiche inviate, rendendo non necessario la maggior parte del traffico di rete generato. Per risolvere questo problema si potrebbe fare in modo di inviare notifiche relative ad un certo dato solo ai lettori interessati. Questo approccio introdurrebbe la necessità da parte dei lettori stessi di poter specificare i dati dei quali si desidera ricevere notifiche a riguardo, aggiungendo complessità alla soluzione.
	\item Non viene effettuata alcuna memorizzazione locale dei dati sul lettore. Ogni volta che un soccorritore necessiterà delle informazioni relative ad un certo paziente dovrà recuperarle sul momento dalla banca dati. Seguendo questo approccio viene resa impossibile la creazione di inconsistenze, al costo di una riduzione delle performance e di un maggior numero di richieste verso la banca dati.
\end{enumerate} 

Oltre a questa problematica, la banca dati non fornisce alcun meccanismo di autenticazione per poter regolare l'accesso ai dati in essa contenuti. Questo significa che, per soddisfare i requisiti di sicurezza, sarà necessario implementare tale meccanismo, impedendo così la lettura dei dati da parte di soggetti non autorizzati. Nella pratica, l'unico modo di fornire una politica di accesso basata sull'identità dei soccorritori e sui loro turni è attraverso la presenza di un componente dedicato, contattabile via Internet dai lettori dei soccorritori stessi. La banca dati dovrà, di conseguenza, poter essere interrogata solo da tale componente, in modo che vi sia un controllo totale sulle richieste verso la stessa. 

L'accesso alla banca dati da parte del nuovo componente potrebbe essere:
\begin{enumerate}
	\item Diretto: le due entità risiedono in uno stesso nodo computazionale o in una stessa rete privata. Così facendo, si potrebbe decidere di esporre sulla rete Internet solo il nuovo componente, garantendo quindi un maggior livello di sicurezza per la banca dati.
	\item Indiretto: l'accesso avviene tramite la rete Internet. In questo caso, la banca dati deve essere configurata in modo da accettare le sole richieste provenienti dal nuovo componente. 
\end{enumerate}

\subsection{Tecnologia di identificazione} \label{tec-id}
Con tecnologia di identificazione si intende il protocollo di connettività che verrà utilizzato per permettere al lettore di recuperare l'identificativo, attraverso un'interazione con l'identificatore. È possibile effettuare un primo abbozzo dell'interazione fra lettore e identificatore, individuando le fasi seguenti:
\begin{enumerate}
	\item Il lettore ricerca tutti gli identificatori situati in prossimità dello stesso.
	\item Il lettore individua l'identificatore più vicino, fra tutti quelli rilevati nella fase di ricerca.
	\item Il lettore contatta l'identificatore, richiedendo l'identificativo.
	\item L'identificatore risponde al lettore con l'identificativo richiesto.
\end{enumerate}
La natura dei dispositivi che realizzano l'interazione (lettore e identificatore) incide sulle possibili tecnologie utilizzabili. L'utilizzo di un device Android come lettore esclude tutte le possibilità da esso non supportate, mentre l'identificatore non pone alcun vincolo sulla scelta, in quanto non è definita in maniera chiara la natura del dispositivo sul quale andrà implementato.

\subsubsection{Analisi dei protocolli di connettività supportati da Android} \label{tec-android}
Android supporta diversi protocolli (variabili da versione a versione) che permettono la connessione e l'interazione fra dispositivi \footnote{\url{https://developer.android.com/guide/topics/connectivity}}. Essi verranno di seguito analizzati, in modo da determinare l'esistenza di almeno un protocollo compatibile con i requisiti del sistema. I protocolli relativi a chiamate audio/video o a connessioni \emph{USB} non sono stati presi in considerazione, in quanto non compatibili con il problema in esame.

\begin{table}[h]
	\centering
	\hspace*{-2.4cm}
	\begin{threeparttable}
		\begin{tabular}{|
				>{\centering}m{.18\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |}
			\hline
			& Wi-Fi & Bluetooth & BLE & Wi-Fi Direct & Wi-Fi Aware & NFC & Contact less smart card \tabularnewline
			\hline
			Supporto Android & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \tabularnewline
			\hline
			Fase di ricerca & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \tabularnewline
			\hline
			Pairing automatico & \xmark & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark \tabularnewline
			\hline
			Range (fra 1 e 3 metri) & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark \tabularnewline
			\hline
			Identificazione device più vicino & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark \tnote{*} & \cmark \tnote{*} \tabularnewline
			\hline
			Sicurezza a tracciabilità & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \cmark \tabularnewline
			\hline
			Sicurezza a masquerade & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark   & \cmark \tabularnewline
			\hline
			Basso consumo & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark \tabularnewline
			\hline
			Costo & \xmark & \cmark & \cmark & \xmark & \xmark & \cmark & \xmark \tabularnewline
			\hline
		\end{tabular}
		\begin{tablenotes} \footnotesize
			\item[*] Si presume che, dato il raggio di funzionamento ristretto di NFC (circa 5 cm), sia sempre identificato un solo dispositivo, che sarà, quindi, il più vicino.
		\end{tablenotes}
		\caption{Riepilogo delle tecnologie supportate da Android considerate.}
		\label{tectable-android}
	\end{threeparttable}
\end{table}

\begin{description}
	\item[Wi-Fi e connessione dati]: sono le tecnologie più comunemente utilizzate su smartphone/tablet per la navigazione in rete. 
	
	Una loro adozione nel sistema risulta problematica, in quanto non forniscono alcun meccanismo che permetta la ricerca di dispositivi nelle vicinanze. Inoltre, un ipotetico identificatore basato su queste tecnologie sarebbe soggetto ad un consumo di batteria elevato, che comprometterebbe la durata del dispositivo. La sicurezza relativa a tracciabilità e masquerade è garantita, in quanto è possibile utilizzare operazioni di crittografia nei messaggi della comunicazione.
	
	\item[Bluetooth]: standard tecnologico per lo scambio di dati in modalità wireless, a brevi distanze, attraverso una frequenza radio a corto raggio. In campo mobile è una delle tecnologie di riferimento per il trasferimento di dati. È caratterizzato da una fase di \emph{scanning}, nella quale vengono ricercati tutti i dispositivi compatibili nelle vicinanze (fino a 100 metri di distanza), per poi aprire una connessione con uno di essi. Prevede una fase di accoppiamento, durante la quale due dispositivi vengono associati come \emph{paired} (è richiesta la conferma esplicita dell'utente). 
	
	La connessione può essere effettuata solamente fra dispositivi precedentemente accoppiati, escludendo un possibile utilizzo di Bluetooth all'interno del sistema, in quanto, da requisiti, la connessione fra i dispositivi deve avvenire senza alcun intervento dell'utente. È possibile integrare delle operazioni di crittografia, in modo da sopperire alle problematiche di tracciabilità e masquerade.
	
	\item[BLE (Bluetooth Low Energy)]: conosciuto anche come \emph{Bluetooth 4.0}, è uno standard tecnologico che si presenta come un'evoluzione del classico Bluetooth. Rispetto al suo predecessore, BLE garantisce un consumo di potenza minimo, cruciale per l'impiego in contesti di \emph{Internet of Things}. Con l'utilizzo esclusivo del protocollo BLE, la durata di un dispositivo, alimentato con un'apposita batteria, può raggiungere e superare i 3 anni indicati nei requisiti del sistema. BLE opera allo stesso livello di distanza di Bluetooth, basandosi su una ricerca dei dispositivi nelle immediate vicinanze. Non necessita, però, della fase di accoppiamento esplicita fra dispositivi, rendendo automatico il processo di connessione. BLE, così come Bluetooth, può essere considerato resistente a tracciabilità e masquerade.
	
	Nonostante ciò, l'utilizzo di BLE all'interno del sistema presenta una criticità evidente nell'identificazione dell'identificatore più vicino al lettore. Supponendo l'impiego di BLE, il lettore sarebbe in grado di scoprire tutti gli identificatori in un raggio che può raggiungere i 100 metri (estremamente più ampio rispetto al raggio di 3 metri espresso nei requisiti). Per limare questa problematica, una soluzione piuttosto banale consiste nel calcolo della distanza di ogni dispositivo rispetto al lettore, in modo da non considerare gli identificatori situati ad una distanza troppo ampia. Il calcolo della distanza di un dispositivo BLE si basa sulla potenza di trasmissione dei dati che può, però, essere variabile da device a device, risultando non affidabile. Questa problematica impedisce, inoltre, di determinare quale sia l'identificatore più vicino al lettore.
	
	\item[Wi-Fi Direct (Wi-Fi Peer-to-Peer)]\footnote{\url{https://www.wi-fi.org/discover-wi-fi/wi-fi-direct}} : è uno standard Wi-Fi che consente a due o più dispositivi di effettuare una connessione Wi-Fi diretta tra loro, anche in assenza dell'accesso ad una rete Wi-Fi. Un dispositivo Wi-Fi Direct emette un segnale continuo verso tutti i dispositivi all'interno dell'area circostante, in modo da scoprire i device disponibili e instaurare una connessione con uno di essi. Per quanto riguarda i campi di applicazione, Wi-Fi Direct si presenta come una valida alternativa a Bluetooth per lo scambio di dati diretto fra dispositivi situati in una certa zona. Rispetto a Bluetooth, opera in un'area più vasta (con un raggio che si può estendere fino a 200 metri) e offre una velocità di trasferimento nettamente superiore, a discapito, però, di un consumo elevato. 
	
	Il raggio di ricerca è troppo ampio per poter considerare Wi-Fi Direct come una tecnologia papabile all'interno del sistema, dato che non esistono meccanismi per determinare, con precisione, la distanza dei dispositivi scoperti nella fase di ricerca. La sicurezza a tracciabilità e masquerade può essere garantita tramite opportune operazioni di crittografia.
	
	\item[Wi-Fi Aware]\footnote{\url{https://www.wi-fi.org/discover-wi-fi/wi-fi-aware}} : estende le funzionalità di Wi-Fi con un'efficiente meccanismo di ricerca (anche in assenza dell'accesso ad una rete Wi-Fi), permettendo continuamente la scoperta di altri dispositivi e servizi all'interno del tipico range Wi-Fi. L'obiettivo è quello di fornire ad un utente una serie di servizi \emph{proximity-based}, lasciando ad egli scegliere quale di essi andare a sfruttare e quali dati con esso condividere. 
	
	La filosofia di Wi-Fi Aware risulta simile alla visione espressa in \autoref{vision}, con la principale differenza che consiste nel metodo di identificazione dell'utente. Infatti, Wi-Fi Aware si basa sul presupposto che un utente sia in possesso di uno smartphone, attraverso il quale può essere notificato di tutti i dispositivi e servizi nelle vicinanze. L'idea alla base di \emph{Proxima} è invece quella di slegare l'utente dallo smartphone e spostare la computazione verso i dispositivi esterni, ovvero gli erogatori di servizi. 
	
	Wi-Fi Aware è in stretta correlazione con Wi-Fi Direct, le due tecnologie sono complementari. Ad esempio, Wi-Fi Direct potrebbe permettere l'individuazione di un certo servizio, sfruttando poi le alte velocità di Wi-Fi Direct per effettuare la connessione ed il relativo scambio di informazioni. Le due tecnologie condividono i medesimi punti deboli, in particolare la difficoltà nella stima delle distanze fra i dispositivi ed il consumo troppo elevato.
	
	\item[NFC (Near Field Communication)] : è uno standard di connettività wireless che consente una comunicazione fra due dispositivi posti a breve distanza l'uno dall'altro. Idealmente la distanza massima di funzionamento è leggermente inferiore ai 20 cm, ma nella maggior parte dei dispositivi si aggira intorno ai 5 cm. Un dispositivo NFC può essere utilizzato, ad esempio, per emulare una \emph{smart card}, in modo da effettuare transazioni direttamente dal proprio smartphone, oppure in modalità \emph{peer-to-peer} per lo scambio di informazioni fra due dispositivi diversi. Una terza modalità, \emph{reader/writer}, risulta essere quella più interessante per il sistema in esame, in quanto permette ad un dispositivo NFC di leggere (e scrivere) un \emph{tag NFC}. Un tag, nella maggior parte dei casi, è un dispositivo passivo (a consumo nullo), in grado di memorizzare una quantità ridotta di informazioni. L'interazione con il reader è resa possibile da quest'ultimo device che fornisce al tag, tramite onde elettromagnetiche, la potenza necessaria per l'attivazione. 
	
	L'identificatore del sistema potrebbe essere implementato come un tag NFC, contenente l'identificativo dell'utente, leggibile attraverso il lettore (device Android) dopo una fase di ricerca. Il raggio di funzionamento ristretto impone un contatto (o quasi) fra lettore e identificatore, che in alcune situazioni di emergenza potrebbe rivelarsi scomodo per il soccorritore, ma d'altro canto garantisce che l'identificatore letto sia quello desiderato. NFC non supporta operazioni di crittografia dei messaggi, non permettendo la risoluzione delle problematiche di tracciabilità e masquerade.
	
	\item[Contactless smart cart]: è un dispositivo passivo, la quale comunica con i lettori tramite il protocollo NFC, ma al contrario dei banali tag descritti in precedenza, possiede, al suo interno, un microprocessore capace di operazioni crittografiche. La crittografia è nella maggior parte dei casi a chiave pubblica, difatti gli ambiti di maggiore utilizzo sono quelli di firma digitale o pagamento elettronico. Essa non dovrà solamente essere alimentata dal lettore, ma dovrà comunicare con esso. Lo scambio dati dal lettore alla carta avviene grazie alla modulazione dell'onda elettromagnetica che il lettore invia alla smart card per alimentarla, mentre le comunicazione in senso contrario avviene attraverso la regolazione, da parte della carta, della potenza assorbita. L'utilizzo di una contactless smart card richiede una infrastruttura ben più complessa del solo NFC, dato che dovranno essere gestite chiavi pubbliche e private a livello di singoli identificatori. Inoltre la comunicazione con esse deve seguire un rigido protocollo (ISO/IEC 14443). Esse sarebbero la soluzione a tutti i problemi di sicurezza espressi precedentemente per l'uso di semplici tag NFC, ma a costo di una più complessa infrastruttura del sistema, e di un costo maggiore per l'identificatore, rispetto a quanto espresso nei requisiti. 
\end{description}

Dalla fase di ricognizione sulle tecnologie attualmente disponibili su Android è conseguita una drastica limitazione dello spettro di quelle utilizzabili all'interno del sistema. In \autoref{tectable-android} sono mostrati i risultati più significativi raccolti in questa fase.

\subsubsection{Analisi di tecnologie alternative} \label{tec-other}
Dall'analisi dei protocolli di connettività supportati da Android, eseguita in \autoref{tec-android}, non è emersa alcuna tecnologia in grado di soddisfare tutti i requisiti. Si procede, dunque, all'analisi di tecnologie alternative che non sono compatibili con Android.

\begin{table}[H]
	\centering
	\begin{threeparttable}
		\begin{tabular}{|
				>{\centering}m{.22\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |
				>{\centering}m{.13\textwidth} |}
			\hline
			& RFID & Infrarossi & Onde radio \tabularnewline
			\hline
			Supporto Android & \xmark & \xmark \tnote{*} & \xmark \tabularnewline
			\hline
			Fase di ricerca & \cmark & \xmark & \cmark \tabularnewline
			\hline
			Pairing automatico & \cmark & \cmark & \cmark \tabularnewline
			\hline
			Range (fra 1 e 3 metri) & \cmark & \cmark & \cmark \tabularnewline
			\hline
			Identificazione device più vicino & \xmark & \xmark & \xmark \tabularnewline
			\hline
			Sicurezza a tracciabilità & \xmark \tnote{\dag} & \cmark & \cmark \tabularnewline
			\hline
			Sicurezza a masquerade & \xmark \tnote{\dag} & \cmark & \cmark \tabularnewline
			\hline
			Basso consumo & \cmark & \xmark & \xmark \tabularnewline
			\hline
			Costo & \xmark & \xmark & \xmark \tabularnewline
			\hline
		\end{tabular}
		\begin{tablenotes} \footnotesize
			\item[*] Alcuni dispositivi Android supportano la comunicazione tramite raggi infrarossi, tuttavia non vi è supporto ufficiale da parte di Android a tale tecnologia.
			\item[\dag] Alcuni UHF RFID di ultima generazione (\emph{EPC Global v2}) supportano blande forme di crittografia, basate su un generatore di numeri pseudocasuali all'interno del tag. Esistono varie pubblicazioni in letteratura su come ottenere sicurezza nella comunicazione tramite RFID, ma nessuna soluzione raggiunge ancora un risultato soddisfacente. 
		\end{tablenotes}
		\caption{Riepilogo delle tecnologie alternative considerate.}
		\label{tectable-other}
	\end{threeparttable}
\end{table}

\begin{description}
	\item[RFID (Radio-Frequency IDentification)]: è una tecnologia wireless di comunicazione, incentrata sull'identificazione di oggetti e lo scambio di informazioni. La tecnologia è molto simile a NFC, descritto in precedenza,  difatti quest'ultimo non è che un caso particolare di RFID. Il protocollo prevede due tipi distinti di dispositivi: lettori e tag. A differenza di NFC non è possibile la comunicazione diretta tra due lettori. I tag si dividono in due categorie: passivi ed attivi. Da qui in avanti saranno trattati solo tag passivi, dato che quelli attivi non hanno vantaggi tangibili nel caso in esame, oltre ad avere lo svantaggio di dover costantemente essere alimentati. Un tag non è altro che un antenna, un microchip ed una memoria non volatile, che può essere in sola lettura o anche scrivibile. Il lettore illumina il tag con un'onda elettromagnetica ad una data frequenza, il tag assorbe la potenza dell'onda e si attiva, trasmettendo il contenuto o una parte soltanto della memoria. Nella versione base dei tag non vi è alcun controllo dell'identità del lettore, quindi ogni dispositivo capace di generare onde alla frequenza richiesta può ricevere i dati. La differenza con NFC è data dalla distanza di comunicazione, che può essere maggiore. Esistono tre principali frequenze di funzionamento dei tag:
	\begin{itemize}
		\item \emph{125kHz} (LF RFID): range di qualche centimetro.
		\item \emph{13.56MHz} (HF RFID o NFC): range massimo di 20 centimetri.
		\item \emph{860-960MHz} (UHF RFID): range dal metro fino ai 10 metri.
	\end{itemize}
	Come si può vedere la tecnologia UHF RFID soddisfa il requisito di distanza, ma, come per NFC, non c'è alcun tipo di sicurezza o crittografia, non risolvendo del tutto le problematiche di tracciabilità e masquerade. Ciò è vero per il protocollo base di RFID, tuttavia esistono ulteriori protocolli, come \emph{EPCGlobal v2} che per i tag UHF prevedono forme blande di crittografia all'interno dei tag, facendo sopratutto affidamento a generatori di numeri pseudo-casuali. Anche a fronte di tali passi in avanti non esistono sul mercato tag RFID in grado di garantire un livello di sicurezza allo stato dell'arte. Oltre a ciò sussiste un grave problema di privacy, dato che chiunque in possesso di un lettore può leggere i dati all'interno di un tag, anche da svariati metri di distanza.
	
	\item[Raggi infrarossi]: tecnologia di comunicazione basata sulla rilevazione ed invio di raggi infrarossi. Essa è stata utilizzata come tecnologia principale per lo scambio di dati tra telefoni cellulari prima dell'avvento di \emph{bluetooth}, ed ancora oggi ampiamente utilizzata nei telecomandi dei dispositivi elettronici domestici (televisioni, stereo \dots). Essa si basa sulla modulazione di onde elettromagnetiche nello spettro infrarosso, con lo scopo di trasmettere dati. Ogni dispositivo può agire sia da ricevitore che da emettitore. Il principale svantaggio di tale tecnologia è dato dalla necessità di visibilità reciproca dei due dispositivi, ad una distanza massima di 1-2 metri. La radiazione infrarossa, infatti, non è penetrante, e viene bloccata da qualsiasi corpo solido frapposto tra i due dispositivi (anche il solo vetro di una finestra potrebbe bloccare la radiazione). Ciò significa anche che non è possibile una fase di ricerca dei dispositivi nelle vicinanze, dato che solamente quelli visibili al fascio elettromagnetico saranno contattabili. Esistono vari protocolli per l'utilizzo di tale tecnologia, alcuni dei quali disponibili anche su alcuni dispositivi Andoid. Uno degli svantaggi principali, oltre all'allineamento, è dato dal fatto che l'identificatore dovrà essere alimentato, e sempre in ascolto nella ricezione di segnali. Ciò può comportare una breve vita degli identificatori, contravvenendo ad un requisito. La sicurezza può e deve essere gestita a livelli più alti, ma avendo un identificatore attivo non ci sono problemi a riguardo. 
	
	\item[Onde radio]: tecnologia basata sullo scambio di informazioni attraverso onde radio, tipicamente con frequenza di 2.4GHz. Esse sono normalmente utilizzate per la comunicazione wireless tra computer e periferiche come tastiera o mouse, in contrapposizione a bluetooth. Il range massimo è tipicamente di qualche metro, ma richiede che ogni dispositivo sia dotato di un captatore di onde radio, ed un trasmettitore. Ciò significa che, similmente alla tecnologia a infrarossi, gli identificatori dovranno essere attivi e sempre in ascolto. Un altro svantaggio è che tutti i dispositivi (lettori e identificatori) sono in grado di leggere tutti i segnali inviati nel raggio di qualche metro. Ciò significa che un malintenzionato potrebbe modificare l'identificatore in modo che sia in grado di processare e leggere tutte le informazioni trasmesse nelle sue vicinanze. Al contrario dei raggi infrarossi analizzati in precedenza non ci sono vincoli sulla visibilità reciproca dei dispositivi. La sicurezza, come per la comunicazione tramite infrarossi, dovrà essere gestita a un livello più alto. Ciò è possibile grazie al fatto di lavorare con identificatori attivi. Il costo del dispositivo identificatore potrebbe risultare superiore a quanto espresso nei requisiti, in quanto si necessita di qualche potenza computazionale. 
\end{description}
I risultati più significativi individuati nella fase di ricognizione delle tecnologie non supportate da Android sono raccolti in \autoref{tectable-other}.

\subsubsection{Considerazioni}
Tra le tecnologie supportate da Android, analizzate in \autoref{tec-android}, quelle che risultano più appropriate per il problema in esame sono NFC (in modalità reader) e contactless smart card. Entrambe non soddisfano, però, il requisito relativo al raggio di funzionamento, rivelatosi uno scoglio insuperabile per ogni tecnologia supportata da Android. Rispetto ad NFC semplice, l'utilizzo di una contactless smart card consentirebbe la risoluzione delle problematiche di sicurezza relative a tracciabilità e masquerade, a discapito, però, di costi elevati, al di fuori del budget definito nei requisiti. 

Per quanto riguarda le tecnologie non supportate da Android, analizzate in \autoref{tec-other}, quella che permette di affrontare il problema in maniera più efficacie è RFID. Tale tecnologia necessiterebbe, però, di un apposito lettore \emph{ad-hoc}, il cui costo, unitamente a quello del tag RFID, supererebbe il budget massimo stabilito nei requisiti.

In conclusione, fra le tecnologie esaminate per l'implementazione della comunicazione fra lettore ed identificatore, nessuna permette di soddisfare la totalità dei requisiti. Si decide, in accordo con il committente, di optare per l'utilizzo di NFC, preferito a contactless smart card per i costi notevolmente inferiori, non considerando i problemi di tracciabilità e masquerade che, nell'ambito del primo soccorso, possono essere trascurati.

\subsection{Autenticazione del soccorritore}
L'autenticazione del soccorritore è necessaria per l'utilizzo del servizio. In una situazione di emergenza, i tempi dedicati a questa fase devono essere minimi ed il meccanismo di autenticazione deve essere solido e non invasivo, evitando errori derivanti da un mancato riconoscimento del soccorritore. Vengono individuate varie possibilità:
\begin{itemize}
	\item \textbf{Username e password}: il meccanismo di autenticazione più diffuso nell'uso quotidiano. In questo caso, ad ogni soccorritore verrebbero assegnate delle credenziali di accesso al sistema. Ad ogni utilizzo dell'applicazione, il soccorritore dovrebbe inserire tali credenziali in modo da confermare la propria identità. In una situazione di emergenza, questo approccio potrebbe risultare problematico, sia per il tempo necessario per l'inserimento, sia per questioni relative alle credenziali, che il soccorritore potrebbe temporaneamente non ricordare.
	\item \textbf{Riconoscimento biometrico}: meccanismo di autenticazione che si basa sulle caratteristiche biometriche dell'utente. Tramite il lettore sarebbe, ad esempio, possibile implementare meccanismi di riconoscimento del volto, riconoscimento dell'impronta digitale e riconoscimento della voce. Tali meccanismi di autenticazione non garantiscono, però, un grado di affidabilità adeguato per il sistema.
	\item \textbf{Lettore}: per slegare il soccorritore dall'obbligo di autenticazione, è possibile delegare tale processo al lettore. In questo modo, sarebbe il lettore che, in automatico, si occuperebbe della fase di autenticazione, permettendo al soccorritore di concentrarsi esclusivamente sul paziente. Questo meccanismo potrebbe essere messo in atto dotando il lettore di una chiave segreta, in grado di identificare un determinato soccorritore. In questo modo, però, si presenterebbe la problematica relativa alla sicurezza della chiave.
	\item \textbf{Identificatore}: è lecito assumere che il soccorritore sia in possesso di un proprio identificatore. Esso presenta un modo per identificare univocamente il soggetto, e potrebbe, quindi, essere utilizzato per attestare l'identità del soccorritore. Come già discusso in \autoref{tec-id}, sarebbe possibile per un malintenzionato recuperare l'identificativo di un soccorritore ed utilizzarlo per superare la fase di autenticazione, risultando così un soggetto autorizzato alla lettura dei dati medici.
\end{itemize}
I meccanismi di autenticazione appena citati potrebbero anche essere combinati tra loro, in modo da garantire una maggiore affidabilità nel riconoscimento, così come una robustezza più elevata a fronte di attacchi informatici.

In accordo con il committente, si è deciso di optare per una soluzione che combina i vantaggi di lettore e identificatore. L'autenticazione avverrà a due livelli, il soccorritore si autenticherà nel sistema tramite il suo identificatore, mentre il lettore confermerà l'identità del soccorritore tramite la chiave segreta.  

\section{Architettura logica}
L'analisi delle problematiche, svolta in \autoref{issues}, congiuntamente allo studio di fattibilità in \autoref{feasibility}, ha portato alla definizione di un'architettura logica, in grado di descrivere struttura, interazione e comportamento del sistema.

Dallo studio di fattibilità è emersa una variazione particolarmente rilevante rispetto ai requisiti espressi in \autoref{requirements}. In accordo con il committente, si è infatti deciso di adottare il protocollo NFC per la trasmissione dell'identificativo da identificatore a lettore. Di conseguenza l'identificatore diviene un tag NFC, all'interno del quale è memorizzato l'identificativo del paziente. Il tag è passivo (non alimentato) e può essere attivato dal lettore nel momento in cui il soccorritore necessita l'identificativo del paziente.

L'utilizzo di NFC provoca un impatto evidente anche sugli scenari di esecuzione del sistema, illustrati in \autoref{scenarios}. Il breve raggio di funzionamento di NFC impone una vicinanza strettissima, prossima al contatto, fra lettore e identificatore, rendendo, di fatto, altamente improbabile l'individuazione di più identificatori nella fase di ricerca di un lettore. Il soccorritore, dopo aver aperto l'applicazione, deve superare una prima fase di autenticazione, che prevede che egli avvicini il lettore al proprio identificatore. Fatto ciò, il soccorritore dovrà avvicinare il lettore all'identificatore del paziente, in modo da ricevere l'identificativo, utilizzato poi per accedere ai dati medici del paziente, contenuti all'interno della banca dati. 

All'interno del sistema sono individuati quattro componenti principali:
\begin{itemize}
	\item \textbf{Patient}: entità attiva che rappresenta il paziente, per mezzo del suo identificatore. Nel sistema, infatti, un paziente è descritto dall'identificativo contenuto all'interno del suo identificatore.  
	\item \textbf{Rescuer}: entità attiva che rappresenta il soccorritore. Nel sistema, un soccorritore è descritto dall'identificativo contenuto all'interno del suo identificatore.
	\item \textbf{Data Control}: entità attiva preposta al controllo degli accessi alla banca dati. Si assicura che i soli medici autorizzati possano entrare in possesso dei dati medici dei pazienti.  
	\item \textbf{Data}: entità attiva che rappresenta il database contenente i dati medici dei pazienti.
\end{itemize}
I componenti individuati sono entità distinte e ben distinguibili tra loro, ognuna con un proprio flusso di controllo logico. Il sistema risulta essere eterogeneo e distribuito. L'interazione tra i componenti riveste un ruolo chiave all'interno del sistema. Essa può essere descritta come segue:
\begin{itemize}
	\item \textbf{Rescuer e Patient}: in \autoref{tec-id} era stata formulata una prima ipotesi in grado di descrivere l'interazione fra lettore (Rescuer) e identificatore (Patient). Essa prevedeva una prima fase di ricerca di tutti i pazienti situati in una certa area. Tale approccio non è più valido, dato il nuovo requisito, che consiste nell'utilizzo di NFC. L'interazione era poi stata definita come \emph{request-response}, con il soccorritore che, effettuando una richiesta al paziente, otteneva una risposta contenente l'identificativo dello stesso. Questa soluzione sembra essere la più adatta per il problema in esame, sia perché garantisce che la trasmissione dell'identificativo avvenga solamente quando richiesto (evitando una continua propagazione dello stesso), sia perché è quella che permette di definire in maniera più corretta un'interazione tramite il protocollo NFC.
	\item \textbf{Rescuer e Data Control}: dopo aver recuperato l'identificativo del paziente, il soccorritore deve reperire i dati medici dalla banca dati, contattando il componente \emph{Data control}. Indipendentemente dal protocollo di comunicazione che si andrà ad utilizzare, dal punto di vista logico l'interazione può essere descritta come una \emph{request-response}, con il soccorritore che richiede i dati medici di un certo paziente e il \emph{Data Control} che risponde in maniera adeguata a seconda che il soccorritore sia autorizzato o meno alla visione dei dati.
	\item \textbf{Data Control e Data}: il \emph{Data Control} non dispone di un accesso diretto ai dati medici, ma deve richiederli al componente nel quale essi sono mantenuti, ovvero \emph{Data}. Anche in questo caso l'interazione è \emph{request-response}.
\end{itemize}

L'architettura logica può essere espressa in maniera formale tramite l’utilizzo del meta-modello
QActor, sviluppato dal professore Antonio Natali. Sulla base dei requisiti e dell'analisi del problema, si procede in maniera incrementale alla realizzazione di tre modelli:
\begin{itemize}
	\item \textbf{Base model}: ogni componente del sistema viene modellato come un \emph{QActor}. I dati medici dei pazienti, contenuti nella base di conoscenza dell'attore \emph{Data}, sono simulati (si trattano solamente nome, cognome e gruppo sanguigno di ogni paziente). Il modello è eseguibile e permette di simulare uno scenario completo di utilizzo del sistema, dall'apertura dell'applicazione del soccorritore fino alla visualizzazione dei dati medici del paziente.
	\item \textbf{Connection model}: estensione del modello di base considerando il problema della connettività. Infatti, il soccorritore necessita di connettività per poter reperire i dati medici del paziente, e nel caso essa non sia presente, il servizio \emph{Proxima} non può essere erogato. All'apertura dell'applicazione deve essere immediatamente notificata al soccorritore l'eventuale mancanza di connettività, in modo da non fargli sprecare tempo prezioso.
	\item \textbf{Man-in-the-middle model}: estensione del \emph{Connection model} con l'introduzione delle problematiche di \emph{sniffing} e \emph{replay attack}. Se i dati medici transitassero in chiaro fra \emph{Data contro} e \emph{Rescuer}, un \emph{man-in-the-middle} potrebbe intercettarli e visualizzarli e/o modificarli a piacere. Per evitare questa problematica, nel modello si è simulato l'utilizzo di crittografia attraverso uno dei più semplici algoritmi crittografici, ovvero il \emph{cifrario di Cesare}. Per semplicità, la crittografia è stata considerata solamente nella comunicazione fra \emph{Data control} e \emph{Rescuer}, ma allo stesso modo potrebbe essere applicata anche alle altre comunicazioni.
\end{itemize}

I modelli realizzati costituiscono una linea guida per la fase di progettazione, racchiudendo l'architettura logica emersa dall'analisi del problema. I modelli sono stati opportunamente testati, in modo da garantire una corretta rappresentazione dei requisiti analizzati. I test implementati in questo stadio dovranno essere verificati anche nelle successive fasi di progettazione e implementazione.

\section{Analisi dei rischi}
In questa sezione verranno analizzati i rischi principali del progetto, ovvero le parti più complesse dello stesse, per le quali non ci sono soluzioni banali o standardizzate. In modo particolare si farà riferimento al rischio di una consegna del sistema ritardata, che non rispetta quindi i tempi prefissati. 

I principali componenti del sistema che presentano rischi per una sua consegna nei tempi prestabiliti sono elencati di seguito: 
\begin{itemize}
	\item \textbf{Interazione con NFC}: l'interazione con l'identificatore dovrà avvenire tramite NFC. Ciò presenta un rischio per il sistema, poiché ciò significa dover intervenire a basso livello, manipolando in modo diretto la memoria ed i sensori all'interno del dispositivo Android. Se non si volesse perseguire questa strada, un possibilità è quella di utilizzare librerie \emph{ad hoc} per l'interazione tramite NFC. Il rischio di tale software è dato dalla sua non controllabilità, ovvero il modello dell'interazione potrebbe essere diverso da quello analizzato e progettato. Ciò porterebbe ad un ripensamento della parte progettuale del sistema, dovendo operare in modo \emph{bottom-up}.
	\item \textbf{Sicurezza delle comunicazioni}: la sicurezza è una feature fondamentale del sistema, ed una sua corretta implementazione è un forte requisito per la sua riuscita. La sicurezza, data la vastità dell'argomento anche se limitato alle sole comunicazioni, non è un concetto semplice da trattare. Essa, infatti, non può essere aggiunta come una \emph{patch} una volta implementato il sistema, ma la sicurezza dovrà essere una parte fondamentale del progetto del sistema (\emph{secure by design}\footnote{\url{https://en.wikipedia.org/wiki/Secure_by_design}}). In particolar modo l'implementazione di comunicazioni sicure, allo stato dell'arte, si basa sulla generazione di chiavi crittografiche e certificati. In fase prototipale ciò aumenta la complessità sia dell'implementazione che del deployment del sistema. Inoltre gli attacchi possibili alla sicurezza della comunicazione sono molteplici, e testare la sicurezza del sistema a fronte anche solo di una parte consistente di essi richiederà ulteriore tempo e lavoro.
	\item \textbf{Scalabilità e availability}: esse sono due proprietà sia del sistema \emph{Proxima} generale, sia del servizio di aiuto in caso di emergenza descritto in \autoref{requirements}. Non esiste alcuna metodologia automatica per progettare e implementare sistemi scalabili e sempre disponibili. Esistono, in letteratura, metodologie generiche, ed alcune soluzioni pratiche al problema (come la replicazione), ma esse non sono valide per ogni sistema. Il rischio principale è quello di sottostimare o sovrastimare la problematica, rendendo il sistema troppo scalabile o troppo poco scalabile. Mentre quest'ultima problematica è comprensibile da tutti, la prima è molto più sottile. Rendere un sistema più scalabile di quanto in realtà sia necessario è un problema, poiché per raggiungere tali risultati non richiesti si è speso tempo (di progettazione, di implementazione\dots) e denaro (deployment di infrastrutture più complesse, replicazione\dots). \`{E} dunque un rischio da non sottovalutare quello di sotto o sovra stimare il livello di scalabilità del sistema, in modo da non allungare i tempi di consegna per funzionalità non richieste. 
	\item \textbf{Nuovi requisiti, o modifica di quelli esistenti}: esso è uno dei maggiori rischi che ogni progetto pone. I requisiti variano, e anche a distanza di tempo possono esserne aggiunti di nuovi o modificati quelli preesistenti. Un sistema \emph{rigido} è senz'altro un grosso rischio per una consegna nei tempi prestabiliti. La costruzione di un \emph{modello} del sistema mitiga il problema, a patto che il modello sia corretto, e accettato dal cliente stesso. Esso dovrà essere facilmente estensibile e modificabile, anche in corso d'opera, e ciò non dovrà pesantemente influire sul tempo richiesto per l'implementazione del sistema finito. Esso dovrà inoltre servire come base per ulteriori estensioni future, in modo che anche a distanza di tempo sia possibile analizzare i nuovi problemi, progettare la modifica al sistema ed implementarla in un lasso di tempo ragionevole. 
	\item \textbf{Cambiamenti nelle API utilizzate}: essa è una problematica nascosta, ma che può portare a gravi ritardi nella consegna. Non esistono progetti software in cui non si fa uso di librerie esterne o parti di codice sviluppate e mantenute da terzi. Un esempio può essere dato dalla \emph{Java Virtual Machine (JVM)}. I cambiamenti di tali dipendenze, sopratutto se non viene mantenuta la piena retro-compatibilità, può portare a gravi ritardi, dovuti allo studio e alla implementazione \emph{ex-novo} di intere parti del progetto. Tale problematica non può essere gestita dal team di sviluppo, ma è dipendente solamente da fattori esterni, per cui non può essere del tutto prevista e prevenuta.
\end{itemize}

\chapter{Piano di lavoro}

\chapter{Progettazione}

\chapter{Implementazione}

\chapter{Testing} 

\chapter{Deployment (?)}

\chapter{Manutenzione}

\chapter{Restrospettiva}
\section{Giudizio finale}
\section{Sviluppi futuri}

 
\end{document}
